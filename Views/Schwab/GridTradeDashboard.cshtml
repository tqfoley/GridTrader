@{
    ViewData["Title"] = "Grid Trade Dashboard";
    ViewData["PageTitle"] = "Grid Trade Dashboard";
}

<div class="container-fluid mt-4">
    <div class="text-center mb-4">
        <img src="/Images/SchwabGridTradeDash.png" alt="Schwab Grid Trade Dashboard" class="img-fluid" style="max-width: 600px;" />
    </div>

    <div class="row">
        <div class="col-12">
            @Html.Partial("_DashboardNav")

            @Html.Partial("_AccountInputs")

            <div class="card mb-4">
                <div class="card-header bg-success text-white">
                    <h5 class="mb-0">QBTS Pending Orders</h5>
                </div>
                <div class="card-body">
                    <form id="ordersForm">
                        <div class="d-grid">
                            <button type="submit" class="btn btn-primary btn-lg">Load Pending Orders</button>
                        </div>
                    </form>
                </div>
            </div>

            <div id="errorMessage" class="alert alert-danger" style="display: none;"></div>
            <div id="loadingMessage" class="alert alert-info" style="display: none;">
                <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                Loading QBTS pending orders...
            </div>

            <div class="card mb-4" id="summaryCard" style="display: none;">
                <div class="card-header bg-info text-white">
                    <h5 class="mb-0">QBTS Price</h5>
                </div>
                <div class="card-body">
                    <div class="row text-center">
                        <div class="col-md-6">
                            <h4 id="schwabPrice" class="text-primary">--</h4>
                            <small class="text-muted">Schwab Price</small>
                        </div>
                        <div class="col-md-6">
                            <h4 id="eodhPrice" class="text-success">--</h4>
                            <small class="text-muted">EODHD Price</small>
                        </div>
                    </div>
                    <div class="text-danger fw-bold mt-2 text-center">⚠️ PRICES MAY BE DELAYED - VERIFY BEFORE TRADING</div>
                </div>
            </div>

            <div class="card" id="pendingTableCard" style="display: none;">
                <div class="card-header bg-warning text-dark">
                    <h5 class="mb-0">QBTS Orders Grid (<span id="pendingOrderCount">0</span> rows)</h5>
                </div>
                <div class="card-body">
                    <p class="text-muted mb-3">All QBTS orders: existing open orders and proposed orders to place, sorted by price.</p>
                    <div class="table-responsive">
                        <table class="table table-striped table-hover">
                            <thead>
                                <tr>
                                    <th>Price</th>
                                    <th>Instruction</th>
                                    <th>Qty</th>
                                    <th>Status</th>
                                    <th>Order ID</th>
                                    <th>Reason</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody id="pendingTableBody">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="noPendingMessage" class="alert alert-success" style="display: none;">
                <strong>All caught up!</strong> No pending orders to place. All price pairs either have open orders or no recent transaction activity.
            </div>

            <div class="card mt-4" id="rawDataCard" style="display: none;">
                <div class="card-header bg-dark text-white d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Raw API Response</h5>
                    <button type="button" id="copyJsonBtn" class="btn btn-outline-light btn-sm">Copy JSON</button>
                </div>
                <div class="card-body">
                    <pre id="rawDataDisplay" class="bg-light p-3" style="max-height: 400px; overflow-y: auto;"></pre>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // Copy JSON button handler
    document.getElementById('copyJsonBtn')?.addEventListener('click', async function() {
        const jsonText = document.getElementById('rawDataDisplay').textContent;
        try {
            await navigator.clipboard.writeText(jsonText);
            this.textContent = 'Copied!';
            setTimeout(() => { this.textContent = 'Copy JSON'; }, 2000);
        } catch (err) {
            this.textContent = 'Failed';
            setTimeout(() => { this.textContent = 'Copy JSON'; }, 2000);
        }
    });

    // Fetch current QBTS prices from both Schwab and EODHD
    let currentPrice = null;
    let schwabPrice = null;
    let eodhPrice = null;

    async function fetchCurrentPrices(password) {
        // Fetch both prices in parallel
        const [schwabResult, eodhResult] = await Promise.allSettled([
            fetchSchwabPrice(password),
            fetchEodhPrice()
        ]);

        // Use Schwab price as primary if available, otherwise EODHD
        currentPrice = schwabPrice || eodhPrice;
        return currentPrice;
    }

    async function fetchSchwabPrice(password) {
        try {
            const response = await fetch(`/Schwab/GetSchwabQuote?symbol=QBTS&password=${encodeURIComponent(password)}`);
            if (response.ok) {
                const data = await response.json();
                // Schwab returns data in format { "QBTS": { "quote": { "lastPrice": 25.50 } } }
                if (data.QBTS && data.QBTS.quote && data.QBTS.quote.lastPrice) {
                    schwabPrice = data.QBTS.quote.lastPrice;
                    document.getElementById('schwabPrice').textContent = `${schwabPrice.toFixed(2)}`;
                }
            }
        } catch (error) {
            console.error('Error fetching Schwab QBTS price:', error);
            document.getElementById('schwabPrice').textContent = 'N/A';
        }
        return schwabPrice;
    }

    async function fetchEodhPrice() {
        try {
            const response = await fetch('/Schwab/GetStockQuote?symbol=QBTS');
            if (response.ok) {
                const data = await response.json();
                if (data.close) {
                    eodhPrice = data.close;
                    document.getElementById('eodhPrice').textContent = `${eodhPrice.toFixed(2)}`;
                }
            }
        } catch (error) {
            console.error('Error fetching EODHD QBTS price:', error);
            document.getElementById('eodhPrice').textContent = 'N/A';
        }
        return eodhPrice;
    }

    // Auto-load if both fields are populated
    window.addEventListener('DOMContentLoaded', function() {
        const savedPassword = sessionStorage.getItem('apiPassword');
        const savedAccountHash = sessionStorage.getItem('accountHash');

        if (savedPassword && savedAccountHash) {
            document.getElementById('ordersForm').dispatchEvent(new Event('submit'));
        }
    });

    document.getElementById('ordersForm').addEventListener('submit', async function(e) {
        e.preventDefault();

        const accountHash = document.getElementById('accountHash').value;
        const accountHash2 = document.getElementById('accountHash2').value;
        const password = document.getElementById('password').value;

        // Hide previous results
        document.getElementById('errorMessage').style.display = 'none';
        document.getElementById('summaryCard').style.display = 'none';
        document.getElementById('pendingTableCard').style.display = 'none';
        document.getElementById('noPendingMessage').style.display = 'none';
        document.getElementById('loadingMessage').style.display = 'block';

        try {
            // Fetch pending orders from first account
            let allPendingData = { pendingOrders: [], openOrderCount: 0, transactionCount: 0 };
            let openOrders = [];

            const response1 = await fetch(`/Schwab/GetQbtsPendingOrders?accountHash=${encodeURIComponent(accountHash)}&password=${encodeURIComponent(password)}`);
            if (response1.ok) {
                const data1 = await response1.json();
                if (data1.pendingOrders) allPendingData.pendingOrders.push(...data1.pendingOrders);
                allPendingData.openOrderCount += data1.openOrderCount || 0;
                allPendingData.transactionCount += data1.transactionCount || 0;
            }

            // Fetch pending orders from second account if populated
            if (accountHash2) {
                const response2 = await fetch(`/Schwab/GetQbtsPendingOrders?accountHash=${encodeURIComponent(accountHash2)}&password=${encodeURIComponent(password)}`);
                if (response2.ok) {
                    const data2 = await response2.json();
                    if (data2.pendingOrders) allPendingData.pendingOrders.push(...data2.pendingOrders);
                    allPendingData.openOrderCount += data2.openOrderCount || 0;
                    allPendingData.transactionCount += data2.transactionCount || 0;
                }
            }

            document.getElementById('loadingMessage').style.display = 'none';

            const data = allPendingData;

            // Also fetch open orders from both accounts
            const ordersResponse1 = await fetch(`/Schwab/GetOrders?accountHash=${encodeURIComponent(accountHash)}&password=${encodeURIComponent(password)}`);
            if (ordersResponse1.ok) {
                const allOrders1 = await ordersResponse1.json();
                const openStatuses = ['WORKING', 'QUEUED', 'ACCEPTED', 'PENDING_ACTIVATION', 'NEW'];
                const filtered1 = (allOrders1 || []).filter(order => {
                    const orderLeg = order.orderLegCollection && order.orderLegCollection[0];
                    const symbol = orderLeg?.instrument?.symbol;
                    return symbol === 'QBTS' && openStatuses.includes(order.status);
                });
                filtered1.forEach(o => o._accountHash = accountHash);
                openOrders.push(...filtered1);
            }

            if (accountHash2) {
                const ordersResponse2 = await fetch(`/Schwab/GetOrders?accountHash=${encodeURIComponent(accountHash2)}&password=${encodeURIComponent(password)}`);
                if (ordersResponse2.ok) {
                    const allOrders2 = await ordersResponse2.json();
                    const openStatuses = ['WORKING', 'QUEUED', 'ACCEPTED', 'PENDING_ACTIVATION', 'NEW'];
                    const filtered2 = (allOrders2 || []).filter(order => {
                        const orderLeg = order.orderLegCollection && order.orderLegCollection[0];
                        const symbol = orderLeg?.instrument?.symbol;
                        return symbol === 'QBTS' && openStatuses.includes(order.status);
                    });
                    filtered2.forEach(o => o._accountHash = accountHash2);
                    openOrders.push(...filtered2);
                }
            }

            // Display raw JSON data
            document.getElementById('rawDataDisplay').textContent = JSON.stringify({ pendingOrders: data, openOrders: openOrders }, null, 2);
            document.getElementById('rawDataCard').style.display = 'block';

            // Fetch current QBTS prices from both sources
            await fetchCurrentPrices(password);
            document.getElementById('summaryCard').style.display = 'block';

            let pendingOrders = data.pendingOrders || [];

            // Filter pending orders based on current price
            // Hide BUY_TO_COVER if buy price > current price
            // Hide SELL_SHORT if sell price < current price
            if (currentPrice) {
                pendingOrders = pendingOrders.filter(order => {
                    if (order.instruction === 'BUY_TO_COVER' || order.instruction === 'BUY') {
                        return order.price <= currentPrice;
                    }
                    if (order.instruction === 'SELL_SHORT' || order.instruction === 'SELL') {
                        return order.price >= currentPrice;
                    }
                    return true;
                });
            }

            // Build unified list of all rows
            const allRows = [];

            // Add pending orders (proposed orders to place)
            pendingOrders.forEach(order => {
                allRows.push({
                    price: order.price,
                    instruction: order.instruction,
                    quantity: order.quantity,
                    status: 'PROPOSED',
                    orderId: null,
                    reason: order.reason || 'N/A',
                    isOpenOrder: false
                });
            });

            // Add open orders
            openOrders.forEach(order => {
                const orderLeg = order.orderLegCollection && order.orderLegCollection[0];
                allRows.push({
                    price: order.price || 0,
                    instruction: orderLeg?.instruction || 'UNKNOWN',
                    quantity: orderLeg?.quantity || 0,
                    status: order.status,
                    orderId: order.orderId,
                    reason: 'Open order',
                    isOpenOrder: true
                });
            });

            // Sort all rows by price
            allRows.sort((a, b) => a.price - b.price);

            if (allRows.length === 0) {
                document.getElementById('noPendingMessage').style.display = 'block';
                return;
            }

            // Populate table
            const tbody = document.getElementById('pendingTableBody');
            tbody.innerHTML = '';

            allRows.forEach(item => {
                const row = document.createElement('tr');

                if (item.isOpenOrder) {
                    // Existing open order row
                    row.innerHTML = `
                        <td><strong>${item.price.toFixed(2)}</strong></td>
                        <td>${item.instruction.replace(/_/g, ' ')}</td>
                        <td>${item.quantity}</td>
                        <td><span class="badge bg-success">${item.status}</span></td>
                        <td>${item.orderId}</td>
                        <td><small>${item.reason}</small></td>
                        <td>
                            <button class="btn btn-danger btn-sm cancel-order-btn"
                                    data-order-id="${item.orderId}"
                                    data-price="${item.price}"
                                    data-instruction="${item.instruction}">
                                Cancel
                            </button>
                        </td>
                    `;
                } else {
                    // Proposed order row
                    row.innerHTML = `
                        <td><strong>${item.price.toFixed(2)}</strong></td>
                        <td>${item.instruction.replace(/_/g, ' ')}</td>
                        <td>${item.quantity}</td>
                        <td><span class="badge bg-secondary">${item.status}</span></td>
                        <td>-</td>
                        <td><small>${item.reason}</small></td>
                        <td>
                            <button class="btn btn-primary btn-sm place-order-btn"
                                    data-symbol="QBTS"
                                    data-quantity="${item.quantity}"
                                    data-price="${item.price}"
                                    data-instruction="${item.instruction}">
                                Place Order
                            </button>
                        </td>
                    `;
                }

                // Add color-coded class based on instruction type
                if (item.instruction === 'BUY' || item.instruction === 'BUY_TO_COVER') {
                    row.classList.add('order-buy');
                } else if (item.instruction === 'SELL' || item.instruction === 'SELL_SHORT') {
                    row.classList.add('order-sell');
                }

                tbody.appendChild(row);
            });

            document.getElementById('pendingOrderCount').textContent = allRows.length;
            document.getElementById('pendingTableCard').style.display = 'block';

        } catch (error) {
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('errorMessage').textContent = `Error: ${error.message}`;
            document.getElementById('errorMessage').style.display = 'block';
        }
    });

    // Handle place order button clicks using event delegation
    document.getElementById('pendingTableBody').addEventListener('click', async function(e) {
        if (e.target.classList.contains('place-order-btn')) {
            const symbol = e.target.getAttribute('data-symbol');
            const quantity = e.target.getAttribute('data-quantity');
            const price = e.target.getAttribute('data-price');
            const instruction = e.target.getAttribute('data-instruction');
            const accountHash = document.getElementById('accountHash').value;
            const password = document.getElementById('password').value;

            // Confirm order placement
            const confirmMsg = `Place this order?\n\n` +
                              `${instruction} ${quantity} shares of ${symbol} at ${price}\n` +
                              `Order Type: LIMIT\n` +
                              `Duration: GTC + Extended Hours`;

            if (!confirm(confirmMsg)) {
                return;
            }

            // Disable button and show loading
            e.target.disabled = true;
            e.target.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';

            try {
                const orderData = {
                    symbol: symbol,
                    quantity: parseInt(quantity),
                    orderType: 'LIMIT',
                    price: parseFloat(price),
                    duration: 'GOOD_TILL_CANCEL',
                    session: 'SEAMLESS',
                    instruction: instruction
                };

                const response = await fetch(`/Schwab/PlaceOrder?accountHash=${encodeURIComponent(accountHash)}&password=${encodeURIComponent(password)}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(orderData)
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    alert('Order placed successfully!');
                    // Remove the row from the table
                    e.target.closest('tr').remove();
                    // Update the pending count
                    const currentCount = parseInt(document.getElementById('pendingOrderCount').textContent);
                    document.getElementById('pendingOrderCount').textContent = currentCount - 1;

                    // If no pending orders left, show success message
                    if (currentCount - 1 === 0) {
                        document.getElementById('pendingTableCard').style.display = 'none';
                        document.getElementById('noPendingMessage').style.display = 'block';
                    }
                } else {
                    alert('Failed to place order: ' + (result.message || 'Unknown error'));
                    e.target.disabled = false;
                    e.target.innerHTML = 'Place Order';
                }
            } catch (error) {
                alert('Error placing order: ' + error.message);
                e.target.disabled = false;
                e.target.innerHTML = 'Place Order';
            }
        }

        // Cancel order button
        if (e.target.classList.contains('cancel-order-btn')) {
            const orderId = e.target.getAttribute('data-order-id');
            const price = e.target.getAttribute('data-price');
            const instruction = e.target.getAttribute('data-instruction');
            const accountHash = document.getElementById('accountHash').value;
            const password = document.getElementById('password').value;

            // Confirm cancellation
            const confirmMsg = `Cancel this order?\n\nOrder ID: ${orderId}\n${instruction.replace(/_/g, ' ')} at ${parseFloat(price).toFixed(2)}`;

            if (!confirm(confirmMsg)) {
                return;
            }

            // Disable button and show loading
            e.target.disabled = true;
            e.target.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';

            try {
                const response = await fetch(`/Schwab/CancelOrder?accountHash=${encodeURIComponent(accountHash)}&orderId=${encodeURIComponent(orderId)}&password=${encodeURIComponent(password)}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    alert('Order cancelled successfully!');
                    // Remove the row from the table
                    e.target.closest('tr').remove();
                    // Update the count
                    const currentCount = parseInt(document.getElementById('pendingOrderCount').textContent);
                    document.getElementById('pendingOrderCount').textContent = currentCount - 1;

                    if (currentCount - 1 === 0) {
                        document.getElementById('pendingTableCard').style.display = 'none';
                        document.getElementById('noPendingMessage').style.display = 'block';
                    }
                } else {
                    alert('Failed to cancel order: ' + (result.message || 'Unknown error'));
                    e.target.disabled = false;
                    e.target.innerHTML = 'Cancel';
                }
            } catch (error) {
                alert('Error cancelling order: ' + error.message);
                e.target.disabled = false;
                e.target.innerHTML = 'Cancel';
            }
        }
    });
</script>

<style>
    .table-responsive {
        max-height: 600px;
        overflow-y: auto;
    }

    .table tr.order-buy,
    .table-striped tbody tr.order-buy,
    .table tr.order-buy td {
        --bs-table-bg: rgba(40, 167, 69, 0.15);
        --bs-table-bg-state: rgba(40, 167, 69, 0.15);
        --bs-table-bg-type: rgba(40, 167, 69, 0.15);
        background-color: rgba(40, 167, 69, 0.15) !important;
    }

    .table tr.order-buy:hover,
    .table tr.order-buy:hover td,
    .table-striped tbody tr.order-buy:hover,
    .table-striped tbody tr.order-buy:hover td,
    .table-hover tbody tr.order-buy:hover,
    .table-hover tbody tr.order-buy:hover td {
        --bs-table-bg: rgba(40, 167, 69, 0.25);
        --bs-table-bg-state: rgba(40, 167, 69, 0.25);
        --bs-table-bg-type: rgba(40, 167, 69, 0.25);
        background-color: rgba(40, 167, 69, 0.25) !important;
    }

    .table tr.order-sell,
    .table-striped tbody tr.order-sell,
    .table tr.order-sell td {
        --bs-table-bg: rgba(220, 53, 69, 0.15);
        --bs-table-bg-state: rgba(220, 53, 69, 0.15);
        --bs-table-bg-type: rgba(220, 53, 69, 0.15);
        background-color: rgba(220, 53, 69, 0.15) !important;
    }

    .table tr.order-sell:hover,
    .table tr.order-sell:hover td,
    .table-striped tbody tr.order-sell:hover,
    .table-striped tbody tr.order-sell:hover td,
    .table-hover tbody tr.order-sell:hover,
    .table-hover tbody tr.order-sell:hover td {
        --bs-table-bg: rgba(220, 53, 69, 0.25);
        --bs-table-bg-state: rgba(220, 53, 69, 0.25);
        --bs-table-bg-type: rgba(220, 53, 69, 0.25);
        background-color: rgba(220, 53, 69, 0.25) !important;
    }
</style>
